{"implementation":"import pandas as pd\nimport numpy as np\n\ndef calculate_sma(series: pd.Series, window: int) -> pd.Series:\n    return series.rolling(window=window, min_periods=window).mean()\n\ndef calculate_ema(series: pd.Series, span: int) -> pd.Series:\n    return series.ewm(span=span, adjust=False).mean()\n\ndef calculate_rsi(series: pd.Series, period: int) -> pd.Series:\n    delta = series.diff()\n    gain = delta.where(delta > 0, 0.0)\n    loss = -delta.where(delta < 0, 0.0)\n\n    avg_gain = gain.rolling(window=period, min_periods=period).mean()\n    avg_loss = loss.rolling(window=period, min_periods=period).mean()\n\n    # Use Wilder's smoothing after initial average\n    avg_gain = avg_gain.combine_first(gain.ewm(alpha=1/period, adjust=False).mean())\n    avg_loss = avg_loss.combine_first(loss.ewm(alpha=1/period, adjust=False).mean())\n\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    return rsi\n\ndef calculate_macd(series: pd.Series) -> tuple:\n    ema12 = calculate_ema(series, 12)\n    ema26 = calculate_ema(series, 26)\n    macd_line = ema12 - ema26\n    signal_line = calculate_ema(macd_line, 9)\n    return macd_line, signal_line\n\ndef detect_macd_cross(macd_line: pd.Series, signal_line: pd.Series) -> tuple:\n    # Need at least two points to detect cross\n    if len(macd_line) < 2 or len(signal_line) < 2:\n        return False, False\n\n    prev_macd = macd_line.iloc[-2]\n    prev_signal = signal_line.iloc[-2]\n    curr_macd = macd_line.iloc[-1]\n    curr_signal = signal_line.iloc[-1]\n\n    cross_above = (prev_macd <= prev_signal) and (curr_macd > curr_signal)\n    cross_below = (prev_macd >= prev_signal) and (curr_macd < curr_signal)\n\n    return cross_above, cross_below\n\ndef run(df, holdings):\n    # Require at least max(50,14)+1 rows to compute all indicators and detect MACD cross on last day\n    required_len = 50 + 14 + 1\n    if df is None or len(df) < required_len:\n        return []\n\n    close = df[\"Close\"]\n\n    sma10 = calculate_sma(close, 10)\n    sma50 = calculate_sma(close, 50)\n    rsi14 = calculate_rsi(close, 14)\n    macd_line, signal_line = calculate_macd(close)\n\n    cross_above, cross_below = detect_macd_cross(macd_line, signal_line)\n\n    last_sma10 = sma10.iloc[-1]\n    last_sma50 = sma50.iloc[-1]\n    last_rsi = rsi14.iloc[-1]\n    last_close = float(close.iloc[-1])\n\n    # Find USD holding\n    usd_holding = None\n    btc_holdings = []\n    for h in holdings:\n        if h.get(\"asset\") == \"USD\" and h.get(\"holding_id\", \"USD\") == \"USD\":\n            usd_holding = h\n        elif h.get(\"asset\") == \"BTC\":\n            btc_holdings.append(h)\n\n    if usd_holding is None:\n        # No USD holding, no cash available\n        usd_holding = {\"amount\": 0.0}\n\n    position = \"btc\" if btc_holdings else \"cash\"\n\n    orders = []\n\n    # Entry condition (buy)\n    if position == \"cash\":\n        if last_sma10 > last_sma50 and last_rsi < 30 and cross_above:\n            available_usd = float(usd_holding.get(\"amount\", 0.0))\n            if available_usd > 0 and last_close > 0:\n                btc_qty = available_usd / last_close\n                if btc_qty > 0:\n                    orders.append({\n                        \"action\": \"BUY\",\n                        \"asset\": \"BTC\",\n                        \"amount\": float(btc_qty),\n                        \"stop_loss\": None,\n                        \"take_profit\": None\n                    })\n\n    # Exit condition (sell)\n    if position == \"btc\":\n        if (last_sma10 < last_sma50) or (last_rsi > 70) or cross_below:\n            for h in btc_holdings:\n                amt = float(h.get(\"amount\", 0.0))\n                hid = h.get(\"holding_id\")\n                if amt > 0 and hid is not None:\n                    orders.append({\n                        \"action\": \"SELL\",\n                        \"holding_id\": hid,\n                        \"amount\": amt\n                    })\n\n    return orders\n"}