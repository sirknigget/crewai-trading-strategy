{
  "implementation": "import pandas as pd\nimport numpy as np\n\ndef ema(series, span):\n    return series.ewm(span=span, adjust=False).mean()\n\ndef rsi(series, period):\n    delta = series.diff()\n    gain = delta.clip(lower=0)\n    loss = -delta.clip(upper=0)\n    avg_gain = gain.rolling(window=period, min_periods=period).mean()\n    avg_loss = loss.rolling(window=period, min_periods=period).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    return rsi\n\ndef atr(df, period):\n    high = df['High']\n    low = df['Low']\n    close = df['Close']\n    prev_close = close.shift(1)\n    tr1 = high - low\n    tr2 = (high - prev_close).abs()\n    tr3 = (low - prev_close).abs()\n    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = tr.rolling(window=period, min_periods=period).mean()\n    return atr\n\ndef get_usd_holding(holdings):\n    for h in holdings:\n        if h['asset'] == 'USD':\n            return h\n    return None\n\ndef get_btc_holdings(holdings):\n    return [h for h in holdings if h['asset'] == 'BTC']\n\ndef extract_date_from_holding_id(holding_id):\n    # Expects holding_id: ..._YYYYMMDD or ..._YYYYMMDD_stopoutYYYYMMDD\n    import re\n    m = re.search(r'_([12][0-9]{7})(?:_stopout([12][0-9]{7}))?$', holding_id)\n    if m:\n        entry = pd.to_datetime(m.group(1), format='%Y%m%d')\n        stopout = pd.to_datetime(m.group(2), format='%Y%m%d') if m.group(2) else None\n        return entry, stopout\n    return None, None\n\ndef find_last_stoploss_exit(holdings):\n    # Return timestamp (cool-down-until date) if a stop-out exit is encoded in past holdings\n    # Since only current holdings are known, try to extract _stopoutYYYYMMDD from BTC holding_ids\n    cooldown_dates = []\n    for h in holdings:\n        if h['asset'] == 'BTC':\n            _, stopout = extract_date_from_holding_id(h['holding_id'])\n            if stopout is not None:\n                cooldown_dates.append(stopout)\n    if cooldown_dates:\n        # Use latest (should be only one)\n        cooldown_start = max(cooldown_dates)\n        cooldown_until = cooldown_start + pd.Timedelta(days=7)\n        return cooldown_until\n    return None\n\ndef run(df, holdings):\n    EMA_FAST = 20\n    EMA_SLOW = 100\n    RSI_PERIOD = 14\n    ATR_PERIOD = 14\n    ATR_MEDIAN = 60\n    RSI_ENTRY = 55\n    RSI_EXIT = 42\n    ATR_TRAIL_MULT = 1.6\n    COOLDOWN_DAYS = 7\n    if df is None or len(df) < max(EMA_SLOW, RSI_PERIOD, ATR_PERIOD, ATR_MEDIAN):\n        return []\n\n    # Indicators\n    ema_fast = ema(df['Close'], EMA_FAST)\n    ema_slow = ema(df['Close'], EMA_SLOW)\n    rsi_vals = rsi(df['Close'], RSI_PERIOD)\n    atr_vals = atr(df, ATR_PERIOD)\n    atr_60med = atr_vals.rolling(ATR_MEDIAN, min_periods=ATR_MEDIAN).median()\n    last_row = df.iloc[-1]\n    last_date = pd.to_datetime(last_row['Date'])\n    last_close = float(last_row['Close'])\n    ind_ema_fast = float(ema_fast.iloc[-1])\n    ind_ema_slow = float(ema_slow.iloc[-1])\n    ind_rsi = float(rsi_vals.iloc[-1])\n    ind_atr = float(atr_vals.iloc[-1])\n    ind_atr_median = float(atr_60med.iloc[-1])\n    usd = get_usd_holding(holdings)\n    btc_holdings = get_btc_holdings(holdings)\n    # --- Cooldown check ---\n    cooldown_until = find_last_stoploss_exit(holdings)\n    cooldown_active = False\n    if cooldown_until is not None and last_date < cooldown_until:\n        cooldown_active = True\n    orders = []\n    # ENTRY: no BTC holding, not cooldown, signal?\n    if not btc_holdings and (not cooldown_active):\n        if (\n            ind_ema_fast > ind_ema_slow and\n            ind_rsi > RSI_ENTRY and\n            ind_atr > ind_atr_median and\n            usd is not None and usd['amount'] > 0 and last_close > 0\n        ):\n            # We BUY all-in with all USD; encode entry_date in holding_id, store stop_loss=None.\n            btc_qty = float(usd['amount']) / last_close\n            orders.append({\n                'action': 'BUY',\n                'asset': 'BTC',\n                'amount': btc_qty,\n                'stop_loss': None,\n                'take_profit': None,\n            })\n    # EXIT: if BTC holding, need to check triggers. Design assumes only 1 holding.\n    elif btc_holdings:\n        # Per all-in-all-out, use the entire holding for exit logic\n        h = btc_holdings[0]\n        entry_price = float(h['unit_value_usd'])\n        entry_date, _ = extract_date_from_holding_id(h['holding_id'])\n        # If date not encoded, fallback: assume entry on earliest df date (failsafe for legacy holdings)\n        if entry_date is None:\n            entry_date = pd.to_datetime(df.iloc[0]['Date'])\n        # Locate index for entry_date (guaranteed sorted by ascending date)\n        entry_idx = df.index[df['Date'] >= entry_date.strftime('%Y-%m-%d')][0] if entry_date is not None else 0\n        closes_since_entry = df['Close'].iloc[entry_idx:]\n        highest_close = closes_since_entry.max()\n        trailing_stop = float(highest_close) - ATR_TRAIL_MULT * ind_atr\n        should_exit_trend = ind_ema_fast < ind_ema_slow\n        should_exit_rsi = ind_rsi < RSI_EXIT\n        should_exit_trailing = last_close < trailing_stop\n        if should_exit_trend or should_exit_rsi or should_exit_trailing:\n            sell_order = {\n                'action': 'SELL',\n                'holding_id': h['holding_id'],\n                'amount': float(h['amount'])\n            }\n            # If exit is trailing stop hit leading to a loss, encode stopout in holding_id via _stopoutYYYYMMDD\n            # Not possible to update holding_id directly here; relies on system downstream\n            orders.append(sell_order)\n    return orders\n"
}